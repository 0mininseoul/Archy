import { formatKSTDate } from "./utils";

// =============================================================================
// Transcript Quality Analysis
// =============================================================================

export type TranscriptQuality = 'rich' | 'sparse' | 'minimal';

/**
 * ì „ì‚¬ë³¸ì˜ í’ˆì§ˆì„ ë¶„ì„í•˜ì—¬ ì ì ˆí•œ ìš”ì•½ ì „ëµì„ ê²°ì •í•©ë‹ˆë‹¤.
 * @param transcript ì „ì‚¬ë³¸ í…ìŠ¤íŠ¸
 * @returns 'rich' | 'sparse' | 'minimal'
 */
export function analyzeTranscriptQuality(transcript: string): TranscriptQuality {
  const trimmed = transcript.trim();
  if (!trimmed) return 'minimal';

  const words = trimmed.split(/\s+/);
  const wordCount = words.length;

  // í•„ëŸ¬ ì›Œë“œ ë° ë¬´ì˜ë¯¸í•œ í‘œí˜„ íŒ¨í„´
  const fillerPatterns = [
    /^[ìŒì–´ê·¸ì €ì•„ìœ¼]$/,
    /^\.{2,}$/,
    /^[ìŒì–´ê·¸ì €ì•„ìœ¼]\.{2,}$/,
    /^ã…‡+$/,
    /^ã…+$/,
  ];

  // ì˜ë¯¸ìˆëŠ” ë‹¨ì–´ í•„í„°ë§ (2ê¸€ì ì´ìƒ + í•„ëŸ¬ê°€ ì•„ë‹Œ ê²ƒ)
  const meaningfulWords = words.filter(word => {
    if (word.length < 2) return false;
    return !fillerPatterns.some(pattern => pattern.test(word));
  });

  const meaningfulRatio = meaningfulWords.length / wordCount;

  // í’ˆì§ˆ ê¸°ì¤€:
  // minimal: 15ë‹¨ì–´ ë¯¸ë§Œ ë˜ëŠ” ì˜ë¯¸ìˆëŠ” ë‹¨ì–´ ë¹„ìœ¨ 30% ë¯¸ë§Œ
  // sparse: 80ë‹¨ì–´ ë¯¸ë§Œ ë˜ëŠ” ì˜ë¯¸ìˆëŠ” ë‹¨ì–´ ë¹„ìœ¨ 50% ë¯¸ë§Œ
  // rich: ê·¸ ì™¸

  if (wordCount < 15 || meaningfulRatio < 0.3) return 'minimal';
  if (wordCount < 80 || meaningfulRatio < 0.5) return 'sparse';
  return 'rich';
}

// =============================================================================
// Prompts
// =============================================================================

// Universal Prompt - í• ë£¨ì‹œë„¤ì´ì…˜ ë°©ì§€ ì œì•½ ì¶”ê°€
const UNIVERSAL_PROMPT = `ë‹¹ì‹ ì€ ì „ë¬¸ ì—ë””í„°ì´ì ì½˜í…ì¸  ìš”ì•½ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. 
ì£¼ì–´ì§„ ë…¹ì·¨ë¡ì„ ë¶„ì„í•˜ì—¬ í•µì‹¬ ë‚´ìš©ì„ íŒŒì•…í•˜ê³ , ì½ê¸° ì‰¬ìš´ ë§ˆí¬ë‹¤ìš´ ë¬¸ì„œë¡œ ì •ë¦¬í•´ì£¼ì„¸ìš”.

## ë…¹ì·¨ë¡
{{transcript}}

## âš ï¸ ì¤‘ìš” ì œì•½ì‚¬í•­ (ì ˆëŒ€ ìœ„ë°˜ ê¸ˆì§€)
1. **ë…¹ì·¨ë¡ì— ì—†ëŠ” ë‚´ìš©ì€ ì ˆëŒ€ ì¶”ê°€í•˜ê±°ë‚˜ ì¶”ì¸¡í•˜ì§€ ë§ˆì„¸ìš”.**
2. ë…¹ì·¨ë¡ì´ ë¶ˆì™„ì „í•˜ê±°ë‚˜ ë‚´ìš©ì´ ë¶€ì¡±í•œ ê²½ìš°:
   - ìˆëŠ” ë‚´ìš©ë§Œ ê°„ê²°í•˜ê²Œ ì •ë¦¬í•˜ì„¸ìš”
   - ì–µì§€ë¡œ ë‚´ìš©ì„ ì±„ìš°ê±°ë‚˜ ë§Œë“¤ì–´ë‚´ì§€ ë§ˆì„¸ìš”
3. ë¶ˆëª…í™•í•œ ë¶€ë¶„ì€ "[ë¶ˆëª…í™•]" ë˜ëŠ” "..." ìœ¼ë¡œ í‘œì‹œí•˜ì„¸ìš”
4. ë…¹ì·¨ë¡ì— ì–¸ê¸‰ë˜ì§€ ì•Šì€ ì„¸ë¶€ì‚¬í•­ì„ ì°½ì‘í•˜ì§€ ë§ˆì„¸ìš”

## í•„ìˆ˜ ìš”êµ¬ì‚¬í•­
ë‹¤ìŒ ê·œì¹™ì„ ì—„ê²©íˆ ì¤€ìˆ˜í•˜ì„¸ìš”:

1. **ì œëª©**: ë¬¸ì„œì˜ ë‚´ìš©ì„ í•œ ì¤„ë¡œ ëª…í™•í•˜ê²Œ ìš”ì•½í•˜ëŠ” ì œëª©ì„ ì‘ì„±í•˜ì„¸ìš”.
2. **3ì¤„ í•µì‹¬ ìš”ì•½**: ì œëª© ë°”ë¡œ ì•„ë˜ì—, ì „ì²´ ë‚´ìš©ì„ ê´€í†µí•˜ëŠ” **ê°€ì¥ ì¤‘ìš”í•œ 3ê°€ì§€ í•µì‹¬ ë‚´ìš©**ì„ ìš”ì•½í•´ì„œ ì ì–´ì£¼ì„¸ìš”. ì´ ë¶€ë¶„ì€ ë°˜ë“œì‹œ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
3. **ìœ ì—°í•œ ë³¸ë¬¸ êµ¬ì„±**: 3ì¤„ ìš”ì•½ ì´í›„ì˜ ë‚´ìš©ì€ ë…¹ì·¨ë¡ì˜ ì„±ê²©ì— ë”°ë¼ ììœ ë¡­ê²Œ êµ¬ì„±í•˜ë˜, **ë°˜ë“œì‹œ ì†Œì œëª©(##, ###)ì„ ì‚¬ìš©í•˜ì—¬ êµ¬ì¡°í™”**í•´ì£¼ì„¸ìš”. ì¤„ê¸€ë¡œë§Œ ê¸¸ê²Œ ëŠ˜ì–´ë†“ì§€ ë§ˆì„¸ìš”.
   - **íšŒì˜ë¼ë©´**: ## ì•ˆê±´, ## ê²°ì • ì‚¬í•­, ## ì•¡ì…˜ ì•„ì´í…œ ë“±ìœ¼ë¡œ ì„¹ì…˜ êµ¬ë¶„.
   - **ê°•ì˜ë¼ë©´**: ## í•™ìŠµ ëª©í‘œ, ## ì£¼ìš” ê°œë…, ## í•µì‹¬ ìš”ì  ë“±ìœ¼ë¡œ ì„¹ì…˜ êµ¬ë¶„.
   - **ë‹¨ìˆœ ëŒ€í™”ë¼ë©´**: ## ì£¼ìš” ëŒ€í™” íë¦„, ## ê²°ë¡  ë“±ìœ¼ë¡œ ì„¹ì…˜ êµ¬ë¶„.
   - **ì–µì§€ìŠ¤ëŸ¬ìš´ êµ¬ì¡°í™” ê¸ˆì§€**: ë‚´ìš©ì´ ì—†ëŠ”ë° ì–µì§€ë¡œ ì„¹ì…˜ì„ ë§Œë“¤ì§€ëŠ” ë§ˆì„¸ìš”. í•˜ì§€ë§Œ ê°€ëŠ¥í•œ í•œ êµ¬ì¡°ì ìœ¼ë¡œ ì •ë¦¬í•´ì£¼ì„¸ìš”.

## ì¶œë ¥ í˜•ì‹
ë°˜ë“œì‹œ ì•„ë˜ í˜•ì‹ì„ ì§€ì¼œì£¼ì„¸ìš”:

[TITLE]
(ì œëª©)
[/TITLE]
[CONTENT]
### ğŸ“Œ 3ì¤„ í•µì‹¬ ìš”ì•½
- (í•µì‹¬ 1)
- (í•µì‹¬ 2)
- (í•µì‹¬ 3)

(ì´í›„ ë‚´ìš©ì€ ììœ ë¡­ê²Œ ë§ˆí¬ë‹¤ìš´ìœ¼ë¡œ ì‘ì„±... ì ì ˆí•œ ì´ëª¨ì§€ ì‚¬ìš© ê¶Œì¥)
[/CONTENT]`;

// Sparse Prompt - ì§§ì€ ë…¹ì·¨ë¡ìš© (80ë‹¨ì–´ ë¯¸ë§Œ)
const SPARSE_PROMPT = `ë‹¹ì‹ ì€ ì „ë¬¸ ì—ë””í„°ì…ë‹ˆë‹¤.
ì£¼ì–´ì§„ ë…¹ì·¨ë¡ì€ ë‚´ìš©ì´ ì§§ìŠµë‹ˆë‹¤. ìˆëŠ” ë‚´ìš©ë§Œ ê°„ê²°í•˜ê²Œ ì •ë¦¬í•´ì£¼ì„¸ìš”.

## ë…¹ì·¨ë¡
{{transcript}}

## âš ï¸ ì¤‘ìš” ì œì•½ì‚¬í•­ (ì ˆëŒ€ ìœ„ë°˜ ê¸ˆì§€)
1. **ë…¹ì·¨ë¡ì— ì—†ëŠ” ë‚´ìš©ì€ ì ˆëŒ€ ì¶”ê°€í•˜ì§€ ë§ˆì„¸ìš”.**
2. ë‚´ìš©ì´ ë¶€ì¡±í•´ë„ ì–µì§€ë¡œ ì±„ìš°ì§€ ë§ˆì„¸ìš”.
3. ë¶ˆëª…í™•í•œ ë¶€ë¶„ì€ ê·¸ëŒ€ë¡œ ë‘ê±°ë‚˜ "[ë¶ˆëª…í™•]"ìœ¼ë¡œ í‘œì‹œí•˜ì„¸ìš”.

## ìš”êµ¬ì‚¬í•­
- ì§§ì€ ë‚´ìš©ì´ë¯€ë¡œ 1-2ì¤„ í•µì‹¬ë§Œ ì •ë¦¬í•˜ì„¸ìš”
- ë‚´ìš©ì´ ë„ˆë¬´ ì§§ìœ¼ë©´ "ë…¹ìŒ ë‚´ìš©ì´ ì§§ì•„ ìš”ì•½ì´ ì œí•œì ì…ë‹ˆë‹¤"ë¼ê³  ëª…ì‹œí•˜ì„¸ìš”
- ë³¸ë¬¸ì€ ìˆëŠ” ë‚´ìš©ë§Œ ê°„ê²°í•˜ê²Œ ì‘ì„±í•˜ì„¸ìš”

## ì¶œë ¥ í˜•ì‹
[TITLE]
(ì œëª©)
[/TITLE]
[CONTENT]
### ğŸ“Œ í•µì‹¬ ë‚´ìš©
- (ìˆëŠ” ë‚´ìš©ë§Œ ì •ë¦¬)

(ê°„ê²°í•œ ë³¸ë¬¸)
[/CONTENT]`;

// Minimal Prompt - ë§¤ìš° ì§§ì€ ë…¹ì·¨ë¡ìš© (15ë‹¨ì–´ ë¯¸ë§Œ)
const MINIMAL_PROMPT = `ë‹¹ì‹ ì€ ì „ë¬¸ ì—ë””í„°ì…ë‹ˆë‹¤.
ì£¼ì–´ì§„ ë…¹ì·¨ë¡ì€ ë§¤ìš° ì§§ìŠµë‹ˆë‹¤. ìˆëŠ” ë‚´ìš© ê·¸ëŒ€ë¡œë§Œ ì •ë¦¬í•´ì£¼ì„¸ìš”.

## ë…¹ì·¨ë¡
{{transcript}}

## âš ï¸ ì ˆëŒ€ ì§€ì¼œì•¼ í•  ê·œì¹™
- **ì ˆëŒ€ë¡œ ë‚´ìš©ì„ ì¶”ê°€í•˜ê±°ë‚˜ ì¶”ì¸¡í•˜ì§€ ë§ˆì„¸ìš”**
- ë…¹ì·¨ë¡ì— ìˆëŠ” ê²ƒë§Œ ê·¸ëŒ€ë¡œ ì •ë¦¬í•˜ì„¸ìš”
- ë‚´ìš©ì´ ë¶€ì¡±í•´ë„ ë§Œë“¤ì–´ë‚´ì§€ ë§ˆì„¸ìš”

## ì¶œë ¥ í˜•ì‹
[TITLE]
(ì§§ì€ ì œëª©)
[/TITLE]
[CONTENT]
ğŸ“ **ë…¹ìŒ ë‚´ìš©ì´ ë§¤ìš° ì§§ì•„ ìš”ì•½ì´ ì œí•œì ì…ë‹ˆë‹¤.**

{{transcript}}
[/CONTENT]`;

// =============================================================================
// Prompt Builders
// =============================================================================

export function buildUniversalPrompt(transcript: string): string {
  const date = formatKSTDate();
  return UNIVERSAL_PROMPT
    .replace("{{transcript}}", transcript)
    .replace("{{date}}", date);
}

export function buildSparsePrompt(transcript: string): string {
  return SPARSE_PROMPT.replace("{{transcript}}", transcript);
}

export function buildMinimalPrompt(transcript: string): string {
  return MINIMAL_PROMPT.replace(/\{\{transcript\}\}/g, transcript);
}

/**
 * ì „ì‚¬ë³¸ í’ˆì§ˆì— ë”°ë¼ ì ì ˆí•œ í”„ë¡¬í”„íŠ¸ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
 * @param transcript ì „ì‚¬ë³¸ í…ìŠ¤íŠ¸
 * @returns ì„ íƒëœ í”„ë¡¬í”„íŠ¸ì™€ í’ˆì§ˆ ì •ë³´
 */
export function buildPromptByQuality(transcript: string): { prompt: string; quality: TranscriptQuality } {
  const quality = analyzeTranscriptQuality(transcript);

  switch (quality) {
    case 'minimal':
      return { prompt: buildMinimalPrompt(transcript), quality };
    case 'sparse':
      return { prompt: buildSparsePrompt(transcript), quality };
    case 'rich':
    default:
      return { prompt: buildUniversalPrompt(transcript), quality };
  }
}
